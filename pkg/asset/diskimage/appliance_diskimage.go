package diskimage

import (
	"github.com/pkg/errors"
	"os"
	"path/filepath"

	applianceAsset "github.com/danielerez/openshift-appliance/pkg/asset"
	"github.com/danielerez/openshift-appliance/pkg/asset/iso"
	"github.com/openshift/assisted-service/pkg/conversions"
	"github.com/openshift/installer/pkg/asset"
	"github.com/sirupsen/logrus"
)

const (
	templatesDir = "../pkg/asset/diskimage/templates"
	outputDir    = "../assets"
)


type userCfgTemplateData struct {
	GrubTimeout           int
	GrubDefault           int
	GrubMenuEntryName     string
	RecoveryPartitionName string
	LiveISO               string
}

type guestfishScriptTemplateData struct {
	ApplianceFileName     string
	DiskSize              int64
	CoreOSImage           string
	StartSector           int64
	EndSector             int64
	RecoveryPartitionName string
	ReservedPartitionGUID string
}

// ApplianceDiskImage is an asset that generates the OpenShift-based appliance.
type ApplianceDiskImage struct {
	releaseImageUrl string
	sizeInGiB       int

	File *asset.File
}

var _ asset.WritableAsset = (*ApplianceDiskImage)(nil)

// Dependencies returns the assets on which the Bootstrap asset depends.
func (a *ApplianceDiskImage) Dependencies() []asset.Asset {
	return []asset.Asset{
		&iso.RecoveryISO{},
		&BaseDiskImage{},
	}
}

func (a *ApplianceDiskImage) getUserCfgTemplateData() *userCfgTemplateData {
	return &userCfgTemplateData{
		GrubTimeout:           applianceAsset.GrubTimeout,
		GrubDefault:           applianceAsset.GrubDefault,
		GrubMenuEntryName:     applianceAsset.GrubMenuEntryName,
		RecoveryPartitionName: applianceAsset.RecoveryPartitionName,
		LiveISO:               applianceAsset.LiveISO,
	}
}


func (a *ApplianceDiskImage) getGuestfishScriptTemplateData() *guestfishScriptTemplateData {
	var diskSize int64
	var sectorSize int64

	sectorSize = 512
	diskSize = 200 // TODO: read disk size from appliance-config.yaml
	coreOSImage := "fedora-coreos-37.20230303.3.0-qemu.x86_64.qcow2" // TODO: get image name via downloaded file.
	recoveryPartitionSize := int64(20) //TODO: convert: recoveryPartitionSize:= $(du --block=$SECTOR_SIZE agent.recovery.iso | cut -f1)
	recoveryPartitionEndSector := (diskSize * conversions.GibToBytes(1) - conversions.MibToBytes(1))/sectorSize
	recoveryPartitionStartSector := recoveryPartitionEndSector - recoveryPartitionSize

	return &guestfishScriptTemplateData{
		ApplianceFileName:     applianceAsset.ApplianceFileName,
		DiskSize:              diskSize,
		CoreOSImage:           coreOSImage,
		StartSector:           recoveryPartitionStartSector,
		EndSector:             recoveryPartitionEndSector,
		RecoveryPartitionName: applianceAsset.RecoveryPartitionName,
		ReservedPartitionGUID: applianceAsset.ReservedPartitionGUID,
	}
}

// Generate generates the image file for to ISO asset.
func (a *ApplianceDiskImage) Generate(dependencies asset.Parents) error {
	logrus.Info("Generating appliance disk image...")
	if err := os.MkdirAll(filepath.Dir(outputDir), 0755); err != nil {
		return errors.Wrap(err, "failed to create dir")
	}
	if err := applianceAsset.RenderTemplateFile(
		applianceAsset.UserCfgFileName, a.getUserCfgTemplateData(), templatesDir, outputDir) ; err != nil {
		return err
	}
	if err := applianceAsset.RenderTemplateFile(
		applianceAsset.GuestfishScriptFileName, a.getGuestfishScriptTemplateData(), templatesDir, outputDir) ; err != nil {
		return err
	}
	return nil
}

// Name returns the human-friendly name of the asset.
func (a *ApplianceDiskImage) Name() string {
	return "Appliance disk image"
}

// Load returns the ISO from disk.
func (a *ApplianceDiskImage) Load(f asset.FileFetcher) (bool, error) {
	// The ISO will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Files returns the files generated by the asset.
func (a *ApplianceDiskImage) Files() []*asset.File {
	if a.File != nil {
		return []*asset.File{a.File}
	}
	return []*asset.File{}
}

